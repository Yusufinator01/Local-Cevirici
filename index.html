<!DOCTYPE html>
<html lang="tr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Yerel Dosya D√∂n√º≈üt√ºr√ºc√º - Convertio Benzeri</title>

    <!-- CSS Stilleri -->
    <style>
      /* Ana sayfa d√ºzeni ve temel stiller */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
      }

      .container {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        padding: 40px;
        max-width: 800px;
        width: 100%;
        backdrop-filter: blur(10px);
      }

      h1 {
        text-align: center;
        color: #333;
        margin-bottom: 10px;
        font-size: 2.5rem;
        font-weight: 700;
      }

      .subtitle {
        text-align: center;
        color: #666;
        margin-bottom: 40px;
        font-size: 1.1rem;
      }

      /* Dosya y√ºkleme alanƒ± */
      .upload-area {
        border: 3px dashed #667eea;
        border-radius: 15px;
        padding: 60px 20px;
        text-align: center;
        transition: all 0.3s ease;
        background: rgba(102, 126, 234, 0.05);
        cursor: pointer;
        position: relative;
        margin-bottom: 30px;
      }

      .upload-area.dragover {
        border-color: #764ba2;
        background: rgba(118, 75, 162, 0.1);
        transform: scale(1.02);
      }

      .upload-area:hover {
        border-color: #764ba2;
        background: rgba(118, 75, 162, 0.08);
      }

      .upload-icon {
        font-size: 4rem;
        color: #667eea;
        margin-bottom: 20px;
      }

      .upload-text {
        font-size: 1.2rem;
        color: #333;
        margin-bottom: 10px;
      }

      .upload-hint {
        color: #666;
        font-size: 0.9rem;
      }

      .file-input {
        display: none;
      }

      /* Dosya bilgi alanƒ± */
      .file-info {
        display: none;
        background: #f8f9fa;
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 20px;
        border-left: 4px solid #667eea;
      }

      .file-name {
        font-weight: 600;
        color: #333;
        margin-bottom: 5px;
      }

      .file-size {
        color: #666;
        font-size: 0.9rem;
      }

      /* Format se√ßim alanƒ± */
      .format-selection {
        display: none;
        margin-bottom: 30px;
      }

      .format-row {
        display: flex;
        align-items: center;
        gap: 20px;
        margin-bottom: 20px;
        flex-wrap: wrap;
      }

      .format-group {
        flex: 1;
        min-width: 200px;
      }

      .format-label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: #333;
      }

      .format-select {
        width: 100%;
        padding: 12px 15px;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        font-size: 1rem;
        background: white;
        cursor: pointer;
        transition: border-color 0.3s ease;
      }

      .format-select:focus {
        outline: none;
        border-color: #667eea;
      }

      .arrow-icon {
        font-size: 1.5rem;
        color: #667eea;
        margin-top: 25px;
      }

      /* ƒ∞≈ülem butonlarƒ± */
      .action-buttons {
        display: none;
        text-align: center;
        margin-bottom: 30px;
      }

      .btn {
        padding: 15px 30px;
        border: none;
        border-radius: 8px;
        font-size: 1.1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        margin: 0 10px;
      }

      .btn-primary {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
      }

      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
      }

      .btn-primary:disabled {
        background: #ccc;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      .btn-secondary {
        background: #f8f9fa;
        color: #333;
        border: 2px solid #e0e0e0;
      }

      .btn-secondary:hover {
        background: #e9ecef;
      }

      /* ƒ∞lerleme √ßubuƒüu */
      .progress-container {
        display: none;
        margin-bottom: 30px;
      }

      .progress-bar {
        width: 100%;
        height: 20px;
        background: #e0e0e0;
        border-radius: 10px;
        overflow: hidden;
        position: relative;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #667eea, #764ba2);
        width: 0%;
        transition: width 0.3s ease;
        position: relative;
      }

      .progress-text {
        text-align: center;
        margin-top: 10px;
        font-weight: 600;
        color: #333;
      }

      /* ƒ∞ndirme alanƒ± */
      .download-area {
        display: none;
        text-align: center;
        padding: 30px;
        background: #f8f9fa;
        border-radius: 15px;
        border: 2px solid #28a745;
      }

      .download-icon {
        font-size: 3rem;
        color: #28a745;
        margin-bottom: 20px;
      }

      .download-text {
        font-size: 1.2rem;
        color: #333;
        margin-bottom: 20px;
      }

      .btn-download {
        background: #28a745;
        color: white;
        padding: 15px 30px;
        border: none;
        border-radius: 8px;
        font-size: 1.1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        text-decoration: none;
        display: inline-block;
      }

      .btn-download:hover {
        background: #218838;
        transform: translateY(-2px);
        box-shadow: 0 10px 20px rgba(40, 167, 69, 0.3);
      }

      /* Hata mesajlarƒ± */
      .error-message {
        display: none;
        background: #f8d7da;
        color: #721c24;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        border-left: 4px solid #dc3545;
      }

      /* Desteklenen formatlar */
      .supported-formats {
        margin-top: 40px;
        text-align: center;
      }

      .formats-title {
        color: #333;
        margin-bottom: 20px;
        font-weight: 600;
      }

      .formats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-top: 20px;
      }

      .format-category {
        background: rgba(255, 255, 255, 0.8);
        padding: 15px;
        border-radius: 10px;
        border: 1px solid #e0e0e0;
      }

      .category-title {
        font-weight: 600;
        color: #667eea;
        margin-bottom: 10px;
      }

      .category-formats {
        font-size: 0.9rem;
        color: #666;
        line-height: 1.4;
      }

      /* Responsive tasarƒ±m */
      @media (max-width: 768px) {
        .container {
          padding: 20px;
          margin: 10px;
        }

        h1 {
          font-size: 2rem;
        }

        .upload-area {
          padding: 40px 15px;
        }

        .format-row {
          flex-direction: column;
        }

        .arrow-icon {
          transform: rotate(90deg);
          margin: 10px 0;
        }

        .btn {
          width: 100%;
          margin: 5px 0;
        }
      }

      /* Animasyonlar */
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .fade-in {
        animation: fadeIn 0.5s ease;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .loading {
        animation: spin 1s linear infinite;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Ba≈ülƒ±k b√∂l√ºm√º -->
      <h1>üîÑ Yerel Dosya D√∂n√º≈üt√ºr√ºc√º</h1>
      <p class="subtitle">
        Dosyalarƒ±nƒ±zƒ± g√ºvenli bir ≈üekilde tarayƒ±cƒ±nƒ±zda d√∂n√º≈üt√ºr√ºn - sunucu
        gerektirmez!
      </p>

      <!-- Hata mesajƒ± alanƒ± -->
      <div id="errorMessage" class="error-message"></div>

      <!-- Dosya y√ºkleme alanƒ± -->
      <div id="uploadArea" class="upload-area">
        <div class="upload-icon">üìÅ</div>
        <div class="upload-text">Dosyanƒ±zƒ± buraya s√ºr√ºkleyip bƒ±rakƒ±n</div>
        <div class="upload-hint">veya tƒ±klayarak dosya se√ßin</div>
        <input type="file" id="fileInput" class="file-input" />
      </div>

      <!-- Se√ßilen dosya bilgileri -->
      <div id="fileInfo" class="file-info">
        <div id="fileName" class="file-name"></div>
        <div id="fileSize" class="file-size"></div>
      </div>

      <!-- Format se√ßim alanƒ± -->
      <div id="formatSelection" class="format-selection">
        <div class="format-row">
          <div class="format-group">
            <label class="format-label">Mevcut Format:</label>
            <select id="fromFormat" class="format-select">
              <option value="">Otomatik algƒ±la</option>
            </select>
          </div>
          <div class="arrow-icon">‚û°Ô∏è</div>
          <div class="format-group">
            <label class="format-label">Hedef Format:</label>
            <select id="toFormat" class="format-select">
              <option value="">Format se√ßin</option>
            </select>
          </div>
        </div>
      </div>

      <!-- ƒ∞≈ülem butonlarƒ± -->
      <div id="actionButtons" class="action-buttons">
        <button id="convertBtn" class="btn btn-primary">üîÑ D√∂n√º≈üt√ºr</button>
        <button id="resetBtn" class="btn btn-secondary">
          üîÑ Yeniden Ba≈üla
        </button>
      </div>

      <!-- ƒ∞lerleme √ßubuƒüu -->
      <div id="progressContainer" class="progress-container">
        <div class="progress-bar">
          <div id="progressFill" class="progress-fill"></div>
        </div>
        <div id="progressText" class="progress-text">ƒ∞≈ülem ba≈ülatƒ±lƒ±yor...</div>
      </div>

      <!-- ƒ∞ndirme alanƒ± -->
      <div id="downloadArea" class="download-area">
        <div class="download-icon">‚úÖ</div>
        <div class="download-text">Dosyanƒ±z ba≈üarƒ±yla d√∂n√º≈üt√ºr√ºld√º!</div>
        <a id="downloadBtn" class="btn-download">üì• ƒ∞ndir</a>
      </div>

      <!-- Desteklenen formatlar -->
      <div class="supported-formats">
        <h3 class="formats-title">Desteklenen Format D√∂n√º≈ü√ºmleri</h3>
        <div class="formats-grid">
          <div class="format-category">
            <div class="category-title">üñºÔ∏è Resim Dosylarƒ±</div>
            <div class="category-formats">JPG, PNG, GIF, BMP, WEBP, SVG</div>
          </div>
          <div class="format-category">
            <div class="category-title">üìÑ D√∂k√ºman Dosylarƒ±</div>
            <div class="category-formats">PDF, DOCX, TXT, HTML, MD</div>
          </div>
        </div>
      </div>
    </div>

    <!-- JavaScript Kodu -->
    <script>
      /**
       * Ana uygulama sƒ±nƒ±fƒ± - t√ºm dosya d√∂n√º≈üt√ºrme i≈ülemlerini y√∂netir
       * Bu sƒ±nƒ±f drag & drop, format se√ßimi, d√∂n√º≈üt√ºrme ve indirme i≈ülemlerini koordine eder
       */
      class FileConverter {
        constructor() {
          // DOM elementlerini al
          this.uploadArea = document.getElementById("uploadArea");
          this.fileInput = document.getElementById("fileInput");
          this.fileInfo = document.getElementById("fileInfo");
          this.fileName = document.getElementById("fileName");
          this.fileSize = document.getElementById("fileSize");
          this.formatSelection = document.getElementById("formatSelection");
          this.fromFormat = document.getElementById("fromFormat");
          this.toFormat = document.getElementById("toFormat");
          this.actionButtons = document.getElementById("actionButtons");
          this.convertBtn = document.getElementById("convertBtn");
          this.resetBtn = document.getElementById("resetBtn");
          this.progressContainer = document.getElementById("progressContainer");
          this.progressFill = document.getElementById("progressFill");
          this.progressText = document.getElementById("progressText");
          this.downloadArea = document.getElementById("downloadArea");
          this.downloadBtn = document.getElementById("downloadBtn");
          this.errorMessage = document.getElementById("errorMessage");

          // Uygulama durumu
          this.currentFile = null;
          this.convertedFile = null;

          // Desteklenen format kategorileri
          this.supportedFormats = {
            // Resim formatlarƒ± - Canvas API ile desteklenir
            image: ["jpg", "jpeg", "png", "gif", "bmp", "webp"],
            // D√∂k√ºman formatlarƒ± - basit metin d√∂n√º≈ü√ºmleri
            document: ["txt", "html", "md", "csv", "json"],
          };

          // Event listener'larƒ± ba≈ülat
          this.initEventListeners();

          // FFmpeg'i y√ºkle (kullanƒ±cƒ± bir medya dosyasƒ± y√ºklediƒüinde)
          this.loadFFmpegWhenNeeded = true;
        }

        /**
         * T√ºm event listener'larƒ± ba≈ülatƒ±r
         * Drag & drop, dosya se√ßimi, buton tƒ±klamalarƒ± vb.
         */
        initEventListeners() {
          // Drag & drop event'leri
          this.uploadArea.addEventListener("dragover", (e) => {
            e.preventDefault();
            console.log("Drag over detected"); // Debug
            this.uploadArea.classList.add("dragover");
          });

          this.uploadArea.addEventListener("dragleave", (e) => {
            e.preventDefault();
            console.log("Drag leave detected"); // Debug
            this.uploadArea.classList.remove("dragover");
          });

          this.uploadArea.addEventListener("drop", (e) => {
            e.preventDefault();
            console.log("Drop detected"); // Debug
            this.uploadArea.classList.remove("dragover");
            const files = e.dataTransfer.files;
            console.log("Dropped files:", files); // Debug
            if (files.length > 0) {
              this.handleFileSelect(files[0]);
            } else {
              console.log("No files in drop event"); // Debug
            }
          });

          // Dosya input tƒ±klama
          this.uploadArea.addEventListener("click", () => {
            console.log("Upload area clicked, opening file dialog"); // Debug
            this.fileInput.click();
          });

          // Dosya se√ßimi
          this.fileInput.addEventListener("change", (e) => {
            console.log("File input changed:", e.target.files); // Debug
            if (e.target.files.length > 0) {
              this.handleFileSelect(e.target.files[0]);
            } else {
              console.log("No files selected"); // Debug
            }
          });

          // Format deƒüi≈üiklikleri
          this.fromFormat.addEventListener("change", () => {
            this.updateToFormatOptions();
          });

          // Buton tƒ±klamalarƒ±
          this.convertBtn.addEventListener("click", () => {
            this.convertFile();
          });

          this.resetBtn.addEventListener("click", () => {
            this.resetApplication();
          });
        }

        /**
         * Se√ßilen dosyayƒ± i≈üler ve UI'ƒ± g√ºnceller
         * @param {File} file - Kullanƒ±cƒ±nƒ±n se√ßtiƒüi dosya
         */
        handleFileSelect(file) {
          console.log("Dosya se√ßildi:", file); // Debug log

          if (!file) {
            this.showError("Ge√ßerli bir dosya se√ßilmedi.");
            return;
          }

          this.currentFile = file;
          this.hideError();

          // Dosya boyutu kontrol√º (100MB limit)
          if (file.size > 100 * 1024 * 1024) {
            this.showError("Dosya boyutu 100MB'dan b√ºy√ºk olamaz.");
            return;
          }

          // Dosya t√ºr√º kontrol√º
          const fileExtension = file.name.split(".").pop().toLowerCase();
          const fileCategory = this.getFileCategory(fileExtension);

          if (!fileCategory) {
            this.showError(
              `Desteklenmeyen dosya formatƒ±: ${fileExtension.toUpperCase()}. Desteklenen formatlar: JPG, PNG, GIF, BMP, WEBP, TXT, HTML, MD, CSV, JSON`
            );
            return;
          }

          console.log("Dosya kategori:", fileCategory); // Debug log

          // Dosya bilgilerini g√∂ster
          this.fileName.textContent = file.name;
          this.fileSize.textContent = this.formatFileSize(file.size);
          this.fileInfo.style.display = "block";
          this.fileInfo.classList.add("fade-in");

          // Format se√ßeneklerini ayarla
          this.setupFormatOptions(file);
          this.formatSelection.style.display = "block";
          this.formatSelection.classList.add("fade-in");

          this.actionButtons.style.display = "block";
          this.actionButtons.classList.add("fade-in");

          console.log("Dosya ba≈üarƒ±yla y√ºklendi!"); // Debug log
        }

        /**
         * Dosya boyutunu okunabilir formata √ßevirir
         * @param {number} bytes - Byte cinsinden dosya boyutu
         * @returns {string} - Formatlanmƒ±≈ü dosya boyutu
         */
        formatFileSize(bytes) {
          if (bytes === 0) return "0 Bytes";
          const k = 1024;
          const sizes = ["Bytes", "KB", "MB", "GB"];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return (
            parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i]
          );
        }

        /**
         * Dosya tipine g√∂re format se√ßeneklerini ayarlar
         * @param {File} file - Se√ßilen dosya
         */
        setupFormatOptions(file) {
          const fileExtension = file.name.split(".").pop().toLowerCase();
          const fileCategory = this.getFileCategory(fileExtension);

          // Kaynak format dropdown'ƒ±nƒ± temizle ve doldur
          this.fromFormat.innerHTML =
            '<option value="">Otomatik algƒ±la</option>';
          this.toFormat.innerHTML = '<option value="">Format se√ßin</option>';

          if (fileCategory) {
            // Mevcut format'ƒ± otomatik se√ß
            const option = document.createElement("option");
            option.value = fileExtension;
            option.textContent = fileExtension.toUpperCase();
            option.selected = true;
            this.fromFormat.appendChild(option);

            // Hedef formatlarƒ± ekle (kendi kategorisi + uyumlu kategoriler)
            this.populateToFormatOptions(fileCategory, fileExtension);
          }
        }

        /**
         * Dosya uzantƒ±sƒ±ndan kategoriyi belirler
         * @param {string} extension - Dosya uzantƒ±sƒ±
         * @returns {string|null} - Dosya kategorisi
         */
        getFileCategory(extension) {
          for (const [category, formats] of Object.entries(
            this.supportedFormats
          )) {
            if (formats.includes(extension)) {
              return category;
            }
          }
          return null;
        }

        /**
         * Hedef format se√ßeneklerini doldurur
         * @param {string} category - Dosya kategorisi
         * @param {string} currentExt - Mevcut dosya uzantƒ±sƒ±
         */
        populateToFormatOptions(category, currentExt) {
          const formats = this.supportedFormats[category];

          formats.forEach((format) => {
            if (format !== currentExt) {
              const option = document.createElement("option");
              option.value = format;
              option.textContent = format.toUpperCase();
              this.toFormat.appendChild(option);
            }
          });
        }

        /**
         * Kaynak format deƒüi≈ütiƒüinde hedef formatlarƒ± g√ºnceller
         */
        updateToFormatOptions() {
          if (!this.currentFile) return;

          const selectedFormat = this.fromFormat.value;
          if (selectedFormat) {
            const category = this.getFileCategory(selectedFormat);
            this.toFormat.innerHTML = '<option value="">Format se√ßin</option>';
            this.populateToFormatOptions(category, selectedFormat);
          }
        }

        /**
         * Ana dosya d√∂n√º≈üt√ºrme fonksiyonu
         * Dosya tipine g√∂re uygun d√∂n√º≈üt√ºrme y√∂ntemini se√ßer
         */
        async convertFile() {
          if (!this.currentFile || !this.toFormat.value) {
            this.showError(
              "L√ºtfen bir dosya se√ßin ve hedef formatƒ± belirleyin."
            );
            return;
          }

          const fromFormat =
            this.fromFormat.value ||
            this.getFileExtension(this.currentFile.name);
          const toFormat = this.toFormat.value;

          this.showProgress("D√∂n√º≈üt√ºrme ba≈ülatƒ±lƒ±yor...");
          this.convertBtn.disabled = true;

          try {
            const fromCategory = this.getFileCategory(fromFormat);
            const toCategory = this.getFileCategory(toFormat);

            let convertedBlob;

            // D√∂n√º≈üt√ºrme y√∂ntemini belirle
            if (fromCategory === "image" && toCategory === "image") {
              // Resim dosyalarƒ± - Canvas kullan
              convertedBlob = await this.convertImage(fromFormat, toFormat);
            } else if (
              fromCategory === "document" &&
              toCategory === "document"
            ) {
              // D√∂k√ºman dosyalarƒ± - basit metin d√∂n√º≈ü√ºm√º
              convertedBlob = await this.convertDocument(fromFormat, toFormat);
            } else {
              throw new Error("Bu format d√∂n√º≈ü√ºm√º hen√ºz desteklenmiyor.");
            }

            this.convertedFile = {
              blob: convertedBlob,
              name: this.generateFileName(toFormat),
            };

            this.showDownload();
          } catch (error) {
            console.error("D√∂n√º≈üt√ºrme hatasƒ±:", error);
            this.showError(
              "D√∂n√º≈üt√ºrme sƒ±rasƒ±nda bir hata olu≈ütu: " + error.message
            );
          } finally {
            this.hideProgress();
            this.convertBtn.disabled = false;
          }
        }

        /**
         * FFmpeg kullanarak medya dosyalarƒ±nƒ± d√∂n√º≈üt√ºr√ºr
         * @param {string} fromFormat - Kaynak format
         * @param {string} toFormat - Hedef format
         * @returns {Promise<Blob>} - D√∂n√º≈üt√ºr√ºlm√º≈ü dosya blob'u
         */
        async convertWithFFmpeg(fromFormat, toFormat) {
          try {
            console.log(
              `FFmpeg d√∂n√º≈üt√ºrme ba≈ülatƒ±lƒ±yor: ${fromFormat} -> ${toFormat}`
            );

            // FFmpeg'i y√ºkle (hen√ºz y√ºklenmemi≈üse)
            if (!this.isFFmpegLoaded) {
              this.updateProgress("FFmpeg k√ºt√ºphanesi y√ºkleniyor...", 10);
              await this.loadFFmpeg();
            }

            this.updateProgress("Dosya i≈üleniyor...", 30);

            // FFmpeg ile dosyayƒ± i≈üle
            const inputFileName = `input.${fromFormat}`;
            const outputFileName = `output.${toFormat}`;

            console.log(
              `Dosya isimleri: ${inputFileName} -> ${outputFileName}`
            );

            // Dosyayƒ± FFmpeg sanal dosya sistemine yaz
            const fileData = new Uint8Array(
              await this.currentFile.arrayBuffer()
            );
            console.log(`Dosya boyutu: ${fileData.length} bytes`);

            this.ffmpeg.FS("writeFile", inputFileName, fileData);

            this.updateProgress("D√∂n√º≈üt√ºrme i≈ülemi ba≈ülatƒ±lƒ±yor...", 50);

            // D√∂n√º≈üt√ºrme komutunu hazƒ±rla
            const command = this.buildFFmpegCommand(
              fromFormat,
              toFormat,
              inputFileName,
              outputFileName
            );

            console.log("FFmpeg komutu:", command);

            // D√∂n√º≈üt√ºrme i≈ülemini √ßalƒ±≈ütƒ±r
            await this.ffmpeg.run(...command);

            this.updateProgress("D√∂n√º≈üt√ºr√ºlen dosya hazƒ±rlanƒ±yor...", 90);

            // D√∂n√º≈üt√ºr√ºlm√º≈ü dosyayƒ± oku
            const data = this.ffmpeg.FS("readFile", outputFileName);
            console.log(`D√∂n√º≈üt√ºr√ºlen dosya boyutu: ${data.length} bytes`);

            // Temizlik
            try {
              this.ffmpeg.FS("unlink", inputFileName);
              this.ffmpeg.FS("unlink", outputFileName);
            } catch (cleanupError) {
              console.warn("Dosya temizleme hatasƒ±:", cleanupError);
            }

            const blob = new Blob([data.buffer], {
              type: this.getMimeType(toFormat),
            });
            console.log("D√∂n√º≈üt√ºrme ba≈üarƒ±lƒ±!");
            return blob;
          } catch (error) {
            console.error("FFmpeg d√∂n√º≈üt√ºrme hatasƒ±:", error);
            throw new Error(`Medya d√∂n√º≈üt√ºrme ba≈üarƒ±sƒ±z: ${error.message}`);
          }
        }

        /**
         * FFmpeg komutunu olu≈üturur
         * @param {string} fromFormat - Kaynak format
         * @param {string} toFormat - Hedef format
         * @param {string} inputFile - Giri≈ü dosya adƒ±
         * @param {string} outputFile - √áƒ±kƒ±≈ü dosya adƒ±
         * @returns {Array} - FFmpeg komut dizisi
         */
        buildFFmpegCommand(fromFormat, toFormat, inputFile, outputFile) {
          let command = ["-i", inputFile];

          console.log(`Komut olu≈üturuluyor: ${fromFormat} -> ${toFormat}`);

          // Ses format d√∂n√º≈ü√ºmleri
          if (toFormat === "mp3") {
            command.push("-c:a", "libmp3lame", "-b:a", "192k", "-ar", "44100");
          } else if (toFormat === "wav") {
            command.push("-c:a", "pcm_s16le", "-ar", "44100");
          } else if (toFormat === "aac") {
            command.push("-c:a", "aac", "-b:a", "128k", "-ar", "44100");
          } else if (toFormat === "ogg") {
            command.push("-c:a", "libvorbis", "-q:a", "4");
          } else if (toFormat === "flac") {
            command.push("-c:a", "flac");
          } else if (toFormat === "m4a") {
            command.push(
              "-c:a",
              "aac",
              "-b:a",
              "128k",
              "-movflags",
              "+faststart"
            );
          }

          // Video format d√∂n√º≈ü√ºmleri
          else if (toFormat === "mp4") {
            if (this.getFileCategory(fromFormat) === "audio") {
              // Ses'ten video'ya (sessiz video)
              command.push(
                "-f",
                "lavfi",
                "-i",
                "color=black:size=640x480:rate=1",
                "-c:v",
                "libx264",
                "-c:a",
                "aac",
                "-shortest",
                "-pix_fmt",
                "yuv420p"
              );
            } else {
              // Video'dan video'ya
              command.push(
                "-c:v",
                "libx264",
                "-c:a",
                "aac",
                "-crf",
                "23",
                "-preset",
                "medium"
              );
            }
          } else if (toFormat === "webm") {
            command.push(
              "-c:v",
              "libvpx",
              "-c:a",
              "libvorbis",
              "-crf",
              "30",
              "-b:v",
              "1M"
            );
          } else if (toFormat === "avi") {
            command.push("-c:v", "libx264", "-c:a", "mp3", "-crf", "23");
          } else if (toFormat === "mov") {
            command.push("-c:v", "libx264", "-c:a", "aac", "-crf", "23");
          } else if (toFormat === "mkv") {
            command.push("-c:v", "libx264", "-c:a", "aac", "-crf", "23");
          }

          // Eƒüer video'dan ses'e d√∂n√º≈ü√ºm ise, sadece ses'i al
          if (
            this.getFileCategory(fromFormat) === "video" &&
            this.getFileCategory(toFormat) === "audio"
          ) {
            command.push("-vn"); // Video akƒ±≈üƒ±nƒ± devre dƒ±≈üƒ± bƒ±rak
          }

          // Genel ayarlar
          command.push("-y"); // Var olan dosyayƒ± √ºzerine yaz
          command.push(outputFile);

          console.log("Olu≈üturulan komut:", command.join(" "));
          return command;
        }

        /**
         * FFmpeg k√ºt√ºphanesini y√ºkler
         * @returns {Promise} - Y√ºkleme promise'i
         */
        async loadFFmpeg() {
          try {
            console.log("FFmpeg y√ºkleniyor...");

            // FFmpeg.wasm k√ºt√ºphanesinin y√ºklenmi≈ü olduƒüunu kontrol et
            if (typeof FFmpeg === "undefined") {
              throw new Error(
                "FFmpeg k√ºt√ºphanesi y√ºklenmemi≈ü. L√ºtfen sayfayƒ± yenileyin."
              );
            }

            const { createFFmpeg } = FFmpeg;

            if (!createFFmpeg) {
              throw new Error("createFFmpeg fonksiyonu bulunamadƒ±.");
            }

            this.ffmpeg = createFFmpeg({
              log: true, // Debug i√ßin a√ßƒ±k
              corePath:
                "https://unpkg.com/@ffmpeg/core@0.12.6/dist/ffmpeg-core.js",
              wasmPath:
                "https://unpkg.com/@ffmpeg/core@0.12.6/dist/ffmpeg-core.wasm",
              // SharedArrayBuffer desteƒüi i√ßin
              mainName: "main",
              progress: (p) => {
                console.log(
                  "FFmpeg ilerleme:",
                  Math.round(p.ratio * 100) + "%"
                );
                if (p.ratio > 0) {
                  this.updateProgress(
                    `D√∂n√º≈üt√ºrme: ${Math.round(p.ratio * 100)}%`,
                    50 + p.ratio * 40
                  );
                }
              },
            });

            console.log("FFmpeg √∂rneƒüi olu≈üturuldu, y√ºkleniyor...");
            await this.ffmpeg.load();

            this.isFFmpegLoaded = true;
            console.log("FFmpeg ba≈üarƒ±yla y√ºklendi!");
          } catch (error) {
            console.error("FFmpeg y√ºkleme hatasƒ±:", error);
            this.isFFmpegLoaded = false;
            throw new Error(
              `FFmpeg y√ºklenemedi: ${error.message}. L√ºtfen internet baƒülantƒ±nƒ±zƒ± kontrol edin ve sayfayƒ± yenileyin.`
            );
          }
        }

        /**
         * Resim dosyalarƒ±nƒ± Canvas API ile d√∂n√º≈üt√ºr√ºr
         * @param {string} fromFormat - Kaynak format
         * @param {string} toFormat - Hedef format
         * @returns {Promise<Blob>} - D√∂n√º≈üt√ºr√ºlm√º≈ü resim blob'u
         */
        async convertImage(fromFormat, toFormat) {
          return new Promise((resolve, reject) => {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            const img = new Image();

            img.onload = () => {
              try {
                this.updateProgress("Resim i≈üleniyor...", 60);

                canvas.width = img.width;
                canvas.height = img.height;

                // Resmi canvas'a √ßiz
                ctx.drawImage(img, 0, 0);

                this.updateProgress("Yeni format hazƒ±rlanƒ±yor...", 85);

                // Yeni formatta blob olu≈ütur
                canvas.toBlob(
                  (blob) => {
                    if (blob) {
                      resolve(blob);
                    } else {
                      reject(new Error("Resim d√∂n√º≈üt√ºr√ºlemedi"));
                    }
                  },
                  this.getMimeType(toFormat),
                  0.9
                );
              } catch (error) {
                reject(error);
              }
            };

            img.onerror = () => {
              reject(new Error("Resim y√ºklenemedi"));
            };

            this.updateProgress("Resim y√ºkleniyor...", 40);
            img.src = URL.createObjectURL(this.currentFile);
          });
        }

        /**
         * D√∂k√ºman dosyalarƒ±nƒ± d√∂n√º≈üt√ºr√ºr (basit metin d√∂n√º≈ü√ºmleri)
         * @param {string} fromFormat - Kaynak format
         * @param {string} toFormat - Hedef format
         * @returns {Promise<Blob>} - D√∂n√º≈üt√ºr√ºlm√º≈ü d√∂k√ºman blob'u
         */
        async convertDocument(fromFormat, toFormat) {
          const text = await this.currentFile.text();
          let convertedText = text;

          this.updateProgress("D√∂k√ºman i≈üleniyor...", 50);

          // Format d√∂n√º≈ü√ºmleri
          if (toFormat === "html" && fromFormat === "txt") {
            convertedText = this.txtToHtml(text);
          } else if (toFormat === "md" && fromFormat === "txt") {
            convertedText = this.txtToMarkdown(text);
          } else if (toFormat === "txt" && fromFormat === "html") {
            convertedText = this.htmlToTxt(text);
          } else if (toFormat === "csv" && fromFormat === "txt") {
            convertedText = this.txtToCsv(text);
          } else if (toFormat === "json" && fromFormat === "csv") {
            convertedText = this.csvToJson(text);
          }

          this.updateProgress("Dosya hazƒ±rlanƒ±yor...", 90);

          return new Blob([convertedText], {
            type: this.getMimeType(toFormat),
          });
        }

        /**
         * Dosya uzantƒ±sƒ±nƒ± alƒ±r
         * @param {string} filename - Dosya adƒ±
         * @returns {string} - Dosya uzantƒ±sƒ±
         */
        getFileExtension(filename) {
          return filename.split(".").pop().toLowerCase();
        }

        /**
         * MIME tipini d√∂nd√ºr√ºr
         * @param {string} format - Dosya formatƒ±
         * @returns {string} - MIME tipi
         */
        getMimeType(format) {
          const mimeTypes = {
            // Resim formatlarƒ±
            jpg: "image/jpeg",
            jpeg: "image/jpeg",
            png: "image/png",
            gif: "image/gif",
            bmp: "image/bmp",
            webp: "image/webp",

            // D√∂k√ºman formatlarƒ±
            txt: "text/plain",
            html: "text/html",
            md: "text/markdown",
            csv: "text/csv",
            json: "application/json",
          };

          return mimeTypes[format] || "application/octet-stream";
        }

        /**
         * Yeni dosya adƒ±nƒ± olu≈üturur
         * @param {string} newExtension - Yeni dosya uzantƒ±sƒ±
         * @returns {string} - Yeni dosya adƒ±
         */
        generateFileName(newExtension) {
          const baseName = this.currentFile.name.replace(/\.[^/.]+$/, "");
          return `${baseName}.${newExtension}`;
        }

        // D√∂k√ºman d√∂n√º≈üt√ºrme yardƒ±mcƒ± fonksiyonlarƒ±
        txtToHtml(text) {
          return `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>D√∂n√º≈üt√ºr√ºlm√º≈ü D√∂k√ºman</title>
</head>
<body>
    <pre>${text.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre>
</body>
</html>`;
        }

        txtToMarkdown(text) {
          return text
            .split("\n")
            .map((line) => {
              if (line.trim() === "") return "";
              return line.startsWith("#") ? line : `${line}`;
            })
            .join("\n");
        }

        htmlToTxt(html) {
          const div = document.createElement("div");
          div.innerHTML = html;
          return div.textContent || div.innerText || "";
        }

        txtToCsv(text) {
          return text
            .split("\n")
            .map((line) => `"${line.replace(/"/g, '""')}"`)
            .join("\n");
        }

        csvToJson(csv) {
          const lines = csv.split("\n").filter((line) => line.trim());
          if (lines.length === 0) return "[]";

          const headers = lines[0]
            .split(",")
            .map((h) => h.replace(/"/g, "").trim());
          const data = lines.slice(1).map((line) => {
            const values = line
              .split(",")
              .map((v) => v.replace(/"/g, "").trim());
            const obj = {};
            headers.forEach((header, index) => {
              obj[header] = values[index] || "";
            });
            return obj;
          });

          return JSON.stringify(data, null, 2);
        }

        /**
         * ƒ∞lerleme √ßubuƒüunu g√∂sterir
         * @param {string} message - ƒ∞lerleme mesajƒ±
         */
        showProgress(message) {
          this.progressContainer.style.display = "block";
          this.progressText.textContent = message;
          this.progressFill.style.width = "0%";
        }

        /**
         * ƒ∞lerleme √ßubuƒüunu g√ºnceller
         * @param {string} message - ƒ∞lerleme mesajƒ±
         * @param {number} percentage - ƒ∞lerleme y√ºzdesi
         */
        updateProgress(message, percentage) {
          this.progressText.textContent = message;
          this.progressFill.style.width = percentage + "%";
        }

        /**
         * ƒ∞lerleme √ßubuƒüunu gizler
         */
        hideProgress() {
          this.progressContainer.style.display = "none";
        }

        /**
         * ƒ∞ndirme alanƒ±nƒ± g√∂sterir
         */
        showDownload() {
          this.downloadArea.style.display = "block";
          this.downloadArea.classList.add("fade-in");

          // ƒ∞ndirme linkini ayarla
          const url = URL.createObjectURL(this.convertedFile.blob);
          this.downloadBtn.href = url;
          this.downloadBtn.download = this.convertedFile.name;

          // ƒ∞ndirme butonuna tƒ±klama eventi
          this.downloadBtn.onclick = () => {
            // URL'yi temizle (bellek sƒ±zƒ±ntƒ±sƒ±nƒ± √∂nle)
            setTimeout(() => {
              URL.revokeObjectURL(url);
            }, 1000);
          };
        }

        /**
         * Hata mesajƒ±nƒ± g√∂sterir
         * @param {string} message - Hata mesajƒ±
         */
        showError(message) {
          this.errorMessage.textContent = message;
          this.errorMessage.style.display = "block";
          this.errorMessage.classList.add("fade-in");
        }

        /**
         * Hata mesajƒ±nƒ± gizler
         */
        hideError() {
          this.errorMessage.style.display = "none";
        }

        /**
         * Uygulamayƒ± sƒ±fƒ±rlar
         */
        resetApplication() {
          // Dosya ve durum temizliƒüi
          this.currentFile = null;
          this.convertedFile = null;

          // Input'u temizle
          this.fileInput.value = "";

          // UI elementlerini gizle
          this.fileInfo.style.display = "none";
          this.formatSelection.style.display = "none";
          this.actionButtons.style.display = "none";
          this.progressContainer.style.display = "none";
          this.downloadArea.style.display = "none";
          this.hideError();

          // Butonlarƒ± aktif et
          this.convertBtn.disabled = false;

          // Dropdown'larƒ± temizle
          this.fromFormat.innerHTML =
            '<option value="">Otomatik algƒ±la</option>';
          this.toFormat.innerHTML = '<option value="">Format se√ßin</option>';
        }
      }

      // Uygulama ba≈ülatma
      document.addEventListener("DOMContentLoaded", () => {
        console.log("DOM i√ßeriƒüi y√ºklendi, uygulama ba≈ülatƒ±lƒ±yor..."); // Debug

        // FFmpeg k√ºt√ºphanesini y√ºkle - daha g√ºncel ve kararlƒ± versiyon
        const script = document.createElement("script");
        script.src =
          "https://unpkg.com/@ffmpeg/ffmpeg@0.12.6/dist/ffmpeg.min.js";
        script.crossOrigin = "anonymous";

        script.onload = () => {
          console.log("FFmpeg k√ºt√ºphanesi ba≈üarƒ±yla y√ºklendi"); // Debug
          console.log(
            "FFmpeg versiyonu:",
            typeof FFmpeg !== "undefined" ? "Y√ºklendi" : "Y√ºklenemedi"
          );

          // Uygulamayƒ± ba≈ülat
          window.fileConverter = new FileConverter();
          console.log("Yerel Dosya D√∂n√º≈üt√ºr√ºc√º hazƒ±r!");

          // Test FFmpeg
          if (typeof FFmpeg !== "undefined" && FFmpeg.createFFmpeg) {
            console.log("FFmpeg ba≈üarƒ±yla y√ºklendi ve kullanƒ±ma hazƒ±r!");
          } else {
            console.warn(
              "FFmpeg y√ºklendi ama createFFmpeg fonksiyonu bulunamadƒ±"
            );
          }
        };

        script.onerror = (error) => {
          console.error("FFmpeg y√ºkleme hatasƒ±:", error);
          console.warn(
            "FFmpeg y√ºklenemedi. Sadece resim ve d√∂k√ºman d√∂n√º≈üt√ºrme mevcut."
          );
          // FFmpeg olmadan da uygulamayƒ± ba≈ülat
          window.fileConverter = new FileConverter();
          console.log("Yerel Dosya D√∂n√º≈üt√ºr√ºc√º hazƒ±r (FFmpeg olmadan)!");

          // Kullanƒ±cƒ±ya bilgi ver
          setTimeout(() => {
            if (window.fileConverter) {
              window.fileConverter.showError(
                "FFmpeg y√ºklenemedi. Sadece resim ve d√∂k√ºman d√∂n√º≈üt√ºrme √∂zellikleri kullanƒ±labilir."
              );
            }
          }, 1000);
        };

        document.head.appendChild(script);
      });
    </script>
  </body>
</html>
